{% extends "base.twig" %}

{% block content %}
	<div class="col-md-8 mx-auto border border-dark p-3 rounded">
		<form
			method="post" action="{{ route_redirect('users.store') }}">
			<!-- firstname -->
			<div class="mb-3">
				<label for="firstname" class="form-label">Nome
					<span class="text-danger">*</span>
				</label>
				<input type="text" value="{{ OLD_INPUT['firstname'] }}" class="form-control border border-dark" id="firstname" name="firstname">
				{{ message('firstname')|raw }}
			</div>

			<!-- lastname -->
			<div class="mb-3">
				<label for="lastname" class="form-label">Sobrenome
					<span class="text-danger">*</span>
				</label>
				<input type="text" value="{{ OLD_INPUT['lastname'] }}" class="form-control border border-dark" id="lastname" name="lastname">
				{{ message('lastname')|raw }}
			</div>

			<!-- E-mail -->
			<div class="mb-3">
				<label for="email" class="form-label">E-mail
					<span class="text-danger">*</span>
				</label>
				<input type="text" value="{{ OLD_INPUT['email'] }}" class="form-control border border-dark" id="email" name="email" data-rules="required|email" autocomplete="email" onkeyup="this.value = this.value.toLowerCase()" aria-required="true" inputmode="email" required>
				{{ message('email')|raw }}
			</div>


			<!-- User profile -->
			<div class="mb-3">
				<label for="role_id" class="form-label">Perfil de Usuário
					<span class="text-danger">*</span>
				</label>
				<select class="form-select border border-dark" id="role_id" name="role_id">
					<option value="">Selecione um perfil</option>
					<option value="1" {{ OLD_INPUT['role_id'] == '1' ? 'selected' : '' }}>Administrador</option>
					<option value="2" {{ OLD_INPUT['role_id'] == '2' ? 'selected' : '' }}>Usuário</option>
					<option value="3" {{ OLD_INPUT['role_id'] == '3' ? 'selected' : '' }}>Moderador</option>
					<option value="4" {{ OLD_INPUT['role_id'] == '4' ? 'selected' : '' }}>Convidado</option>
				</select>
				{{ message('role_id')|raw }}
			</div>

			<!-- Password -->
			<div class="mb-3">
				<label for="senha" class="form-label">Senha
					<span class="text-danger">*</span>
				</label>
				<input type="password" value="{{ OLD_INPUT['password'] }}" class="form-control border border-dark" id="password" name="password" minlength="6">
				{{ message('password')|raw }}
				<div class="form-text">A senha deve conter pelo menos 6 caracteres.</div>
			</div>

			<!-- Submit button -->
			<div>
				<button type="submit" class="btn btn-primary">Cadastrar</button>
			</div>
		</form>
	</div>


	<script>
		class FormValidator {
constructor(formSelector) {
this.form = document.querySelector(formSelector);
this.isSubmitting = false;
this.isTogglingPassword = false;

if (!this.form) {
throw new Error('Formulário não encontrado');
}

this.init();
}

init() {
this.form.setAttribute('novalidate', 'true');
this.setupEventListeners();
}

setupEventListeners() {
this.form.addEventListener('submit', (e) => this.handleSubmit(e));

this.form.querySelectorAll('input').forEach(input => { // Só valida no focusout se não estiver alternando a senha
input.addEventListener('focusout', () => {
if (!this.isTogglingPassword) {
this.validateField(input);
}
});
});

// Configuração do botão de mostrar/ocultar senha
const toggleButton = document.getElementById('togglePassword');
const passwordInput = document.getElementById('password');

if (toggleButton && passwordInput) {
toggleButton.addEventListener('click', () => this.togglePassword(passwordInput, toggleButton));
}
}

validateOnType(input) {
if (input.dataset.rules && input.value.length > 0) {
this.validateField(input);
}
}

togglePassword(input, button) {
this.isTogglingPassword = true;
const type = input.getAttribute('type') === 'password' ? 'text' : 'password';
input.setAttribute('type', type);
button.textContent = type === 'password' ? 'Mostrar senha' : 'Ocultar senha';
button.setAttribute('aria-label', `${
type === 'password' ? 'Mostrar' : 'Ocultar'
} senha`);

// Mantém o foco no input sem trigger de validação
input.focus();

// Restaura a validação após um pequeno delay
setTimeout(() => {
this.isTogglingPassword = false;
}, 100);
}

validateField(input) { // Se estiver alternando a senha, não valida
if (this.isTogglingPassword) 
return true;



const rules = input.dataset.rules;
if (! rules) 
return true;



const rulesArray = rules.split('|');
let isValid = true;
let errorMessage = '';

for (const rule of rulesArray) {
const [ruleName, ruleValue] = rule.split('=');
const validationResult = this.validateRule(input, ruleName, ruleValue);

if (validationResult !== true) {
isValid = false;
errorMessage = validationResult;
break;
}
}

this.updateFieldStatus(input, isValid, errorMessage);
return isValid;
}

validateRule(input, ruleName, ruleValue) {
const value = input.value.trim();

switch (ruleName) {
case 'required':
return value !== '' || 'Este campo é obrigatório';

case 'min':
return value.length >= parseInt(ruleValue) || `Este campo deve ter pelo menos ${ruleValue} caracteres`;

case 'max':
return value.length<= parseInt(ruleValue) ||
	`Este campo pode ter no máximo ${ruleValue} caracteres`;

case 'email':
	const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2, }$/;
	return !value || emailRegex.test(value) || 'Digite um e-mail válido';

case 'onlyLetter':
	const onlyLetterRegex = /^[A-Za-záàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ ]+$/;
	return !value || onlyLetterRegex.test(value) || 'Somente letras é permitido neste campo';

default:
	console.warn(`Regra de validação desconhecida: ${ruleName}`);
	return true;
}
}

updateFieldStatus(input, isValid, errorMessage = '') {
	const formGroup = input.closest('.form-group');
	const existingError = formGroup.querySelector('.error');

	if (existingError) {
		existingError.remove();
	}

	input.setAttribute('aria-invalid', !isValid);
	input.style.borderColor = isValid ? '' : 'var(--error-color)';

	if (!isValid) {
		const errorDiv = document.createElement('div');
		errorDiv.className = 'error';
		errorDiv.setAttribute('role', 'alert');
		errorDiv.textContent = errorMessage;
		formGroup.appendChild(errorDiv);
	}
}

async handleSubmit(event) {
	event.preventDefault();

	if (this.isSubmitting) return;

	let isFormValid = true;
	const inputs = this.form.querySelectorAll('input');

	inputs.forEach(input => {
if (!this.validateField(input)) {
isFormValid = false;
}
}
);

if (isFormValid) {
const submitButton = this.form.querySelector('button[type="submit"]');

try {
this.isSubmitting = true;
submitButton.classList.add('loading');

// Simular delay de rede (remover em produção)
await new Promise(resolve => setTimeout(resolve, 1000));

// Aqui você pode adicionar sua lógica de envio
this.form.submit();
} catch (error) {
console.error('Erro ao enviar formulário:', error);
// Adicione tratamento de erro apropriado aqui
} finally {
this.isSubmitting = false;
submitButton.classList.remove('loading');
}
} else {
const firstError = this.form.querySelector('[aria-invalid="true"]');
if (firstError) {
firstError.focus();
}
}
}

clearErrors() {
this.form.querySelectorAll('.error').forEach(error => error.remove());
this.form.querySelectorAll('input').forEach(input => {
input.style.borderColor = '';
input.setAttribute('aria-invalid', 'false');
});
}
}

// Inicialização do validador
document.addEventListener('DOMContentLoaded', () => {
try {
new FormValidator('.validator-form');
} catch (error) {
console.error('Erro ao inicializar o validador:', error);
}
});
	</script>
{% endblock %}
